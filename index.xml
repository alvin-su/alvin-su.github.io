<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Alvinsu Blog</title>
    <link>https://alvin-su.github.io/</link>
    <description>Recent content on Alvinsu Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 20 Jun 2022 09:15:49 +0800</lastBuildDate><atom:link href="https://alvin-su.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Go结构体</title>
      <link>https://alvin-su.github.io/post/go%E7%BB%93%E6%9E%84%E4%BD%93/</link>
      <pubDate>Mon, 20 Jun 2022 09:15:49 +0800</pubDate>
      
      <guid>https://alvin-su.github.io/post/go%E7%BB%93%E6%9E%84%E4%BD%93/</guid>
      <description>Go结构体数组、切片以及映射（字典）只能保存一种数据类型。如果需要一个保存多种数据类型的结构，这个时候就需要用到 struct 结构体。
什么是结构体一个struct是一个由其他不同的多种值构造出来的。一个struct可以保存string、int、float64等多种类型。使用struct关键字来声明一个struct，后面跟着{}花括号。在括号中可以定义一个或多个字段，每一个字段定义在一个单独的行中，由字段名称、后面跟着字段需要保存的值的类型组成。
struct {  field1 string,  field2 int } 可以使用一个struct类型来作为定义的变量的类型。下面的代码定义了一个名为myStruct的变量，它保存float64类型的number字段、string类型的word字段和bool类型的toggle字段。
var myStruct struct {  number float64  word string  toggle bool } fmt.Printf(&amp;#34;%#v\n&amp;#34;,myStruct) 使用Printf函数中的%#v将myStruct变量作为字面量打印。
定义类型和struct上面定义一个struct类型的变量是比较麻烦的，如果我们需要定义多个myStruct变量，那么就需要重复整个struct声明，如下：
var myStruct1 struct {  number float64  word string  toggle bool }  var myStruct2 struct {  number float64  word string  toggle bool } 为了解决上面的问题，可以创建自己的类型。类型定义允许你创建新的类型，可以基于基础类型来创建新的定义类型。我们可以使用任何基础类型来创建自己的类型，比如int、string等。但是我们现在专注于struct作为基础类型。</description>
    </item>
    
    <item>
      <title>Docker简介和基本技术</title>
      <link>https://alvin-su.github.io/post/docker%E7%AE%80%E4%BB%8B%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%8A%80%E6%9C%AF/</link>
      <pubDate>Wed, 15 Jun 2022 09:19:17 +0800</pubDate>
      
      <guid>https://alvin-su.github.io/post/docker%E7%AE%80%E4%BB%8B%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%8A%80%E6%9C%AF/</guid>
      <description>Docker基本介绍在介绍Docker技术之前，我们先来看一下容器的发展之路
容器的发展之路现在容器无疑成为了一种潮流，为了我们更全面的了解Docker，我们需要先了解容器技术的发展。
 容器为什么会出现 容器的作用 容器的应用场景  落后的旧时代这个时代也就是服务器时代，业务是基于应用运转的，如果应用出现故障，业务也就无法正常运行，而大部分应用运行在服务器之上，曾经是每个服务器只能运行单一应用。windows和linux系统都无法保证稳定而安全的运行多个应用。在那个时代，经常会出现业务部分需要一个新的应用时，IT部分就去采购一台服务器，往往采购的服务器都是性能比较好的，因为你无法提前知道该应用所需的服务器性能究竟是怎样的。其实这是对公司资产的极大浪费。、
虚拟机时代VMware 公司带来了虚拟机 VM。虚拟机是一种划时代的技术！现在每当业务部分需要增加应用的时候，IT部分无须再采购新的服务器。只需要在现有的空闲的服务器上启用一个新的虚拟机来部署应用。
但是虚拟机也有非常多的不足之处。虚拟机需要依赖其专用的操作系统，操作系统会占用额外的CPU、RAM和存储，每个操作系统都需要补丁和监控。如果是 widnows 操作系统还需要付费购买许可证。虚拟机启动也比较慢，并且可移植性比较差。
容器时代容器完美的解决了虚拟机的不足之处，容器运行不会独占操作系统。实际上，运行在相同宿主机上的容器是共享一个操作系统的，这样能够节省大量的系统资源，如CPU、RAM以及存储。容器还节省了操作系统的许可证，以及操作系统打补丁等运维成本。容器还具有启动速度快和便于迁移等优势。
容器其实是一种沙盒技术。顾名思义，沙盒就是能够像一个集装箱一样，把你的应用“装”起来的技术。这样，应用与应用之间，就因为有了边界而不至于相互干扰；而被装进集装箱的应用，也可以被方便地搬来搬去。
容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造出一个“边界”。Cgroups 技术是用来制造约束的主要手段，而 Namespace 技术则是用来修改进程视图的主要方法。Linux Cgroups 就是 Linux 内核中用来为进程设置资源限制的一个重要功能。Linux Cgroups 的全称是 Linux Control Group它最主要的作用，就是限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等。
现代容器技术起源于linux时代，容器技术已经非常出色，但是对于大部分公司来说还是比较复杂，比如，内核命名空间、Control Group、Union File System，容器技术的复杂度是阻止其实际运用的主要原因。
Docker 时代Docker技术的出现，让容器技术变的简单，容器才真正被大众所接受。我们也可以说是 Dcoker这家公司让容器变得简单。
Dokcer简介Dokcer 是一种运行于Linux和windows上的软件，用于创建、管理和编排容器。Docker是在Github上开发的Moby开源项目的一部分。 (https://github.com/moby/moby)
容器编排容器本身没有价值，有价值的是容器编排。正因为如此，容器技术生态才爆发了一场关于“容器编排”的“战争”。而这次战争，最终以 Kubernetes 项目和 CNCF 社区的胜利而告终。</description>
    </item>
    
    <item>
      <title>领域事件和DDD分层架构</title>
      <link>https://alvin-su.github.io/post/%E9%A2%86%E5%9F%9F%E4%BA%8B%E4%BB%B6%E5%92%8Cddd%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Thu, 09 Jun 2022 10:16:35 +0800</pubDate>
      
      <guid>https://alvin-su.github.io/post/%E9%A2%86%E5%9F%9F%E4%BA%8B%E4%BB%B6%E5%92%8Cddd%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84/</guid>
      <description>领域事件和DDD分层架构在理解领域事件之前，我们先来看看什么是领域服务
领域服务我们先来看聚合存在的三个问题：
  聚合无法封装不稳定的领域行为
聚合封装了多个实体和值对象，聚合根是访问聚合的唯一入口点。领域行为被固化在聚合之中，问题在于，虽然一些领域行为需要访问集合封装的信息，它的实现却不稳定，常常随着需求的变化而变化。无法将领域行为分配到一个固定的对象。
  两个聚合之间的协作该由谁发起负责？
多数时候，一个自治的聚合无法完成一个完整的业务服务，聚合之间需要协作。比如一个聚合的根实体作为参数传递给另一个聚合根实体的方法，去完成行为的协作。那么这两个位聚合之间的协作该由谁负责？
  聚合如何与外部组件协作？
聚合是领域层的自治设计单元，封装了系统最为核心的业务功能。为了保证领域模型的纯粹性，会分离领域逻辑与技术实现，但是为了满足完整业务需要，二者又需要有机的结合起来。
  为了解决上面三个问题，需要引入领域服务的概念。领域服务 与实体、值对象一样，表示了领域模型。它封装了领域行为，前提是改领域行为在实体和值对象中找不到栖息之地。领域服务是领域设计建模的最后选择。
为了限制领域服务的范围，防止削弱聚合内实体和值对象的领域行为，我们需要控制领域服务的粒度，保证领域服务实现一个单一职责的领域行为，领域服务并不反映真实世界的领域概念（名词），而是单纯的体现一种领域行为（动词）。所以在领域服务的命名上必须包含动词，比如：OrderDeletionService这样的类，体现了领域服务的行为本质。
领域服务的运用场景领域服务是为了解决聚合的三个问题的
  聚合无法封装不稳定的领域行为
比如一个调查问卷的聚合，业务需求现在要求将调查问卷导出为CSV格式，隔一段时间又要求导出为JSON格式。转换行为操作由调查问卷聚合拥有，但是转换行为存在着多种变化，不同的格式代表了不同的实现。显然，该行为的变化原因与调查问卷的结构无关，所以我们需要将转换行为和聚合分开，分离变化与不变，变化的领域行为从聚合中分离出来，形成领域服务。
  两个聚合之间的协作该由谁负责?
多数时候，一个自治的聚合无法完成一个完整的业务需求，聚合之间需要协作。通常是一个聚合的根实体作为参数传递给另一个聚合根实体的方法，从而完成行为的协作。
聚合的生命周期由资源库管理，故而两个聚合的协作行为之上，需要引入一个设计对象负责聚合的协作。这个设计对象就是 领域服务 。
领域服务调用资源库获得聚合，发起它们之间的行为协作。
 聚合如何与外部组件的协作?  在业务系统中，几乎不可能让领域逻辑完全不依赖于任何外部资源，如果领域行为突破了聚合的粒度，就需要与外部资源进行协作，比如访问南北向的网关，这个协作就交由领域服务来实现，
  哪些领域行为要分配给聚合，哪些因为聚合无法做到，才会考虑分配给领域服务？
 与状态无关的领域行为 变化方向与聚合不一致的领域行为 聚合之间协作的领域行为 聚合和端口之间协作的领域行为  领域事件领域事件重点关注 状态 这两个字，在进行领域建模时，状态往往作为对象的属性被定义，例如，订单对象定义的订单状态的属性Created、Registered、Canceled等等。领域驱动设计将状态赋予它 领域事件 的身份。领域事件具有如下特征：
 领域事件代表了领域概念 领域事件是已经发送的事实 领域事件是不可变的领域对象 领域事件会基于某个条件而触发  领域事件的命名应采用动词的过去时态，如订单完成的事件命名为OrderCompleted。作为不变事实的领域事件可以参考值对象的定义要求，定义为不变类。</description>
    </item>
    
    <item>
      <title>调用函数</title>
      <link>https://alvin-su.github.io/post/%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sat, 04 Jun 2022 22:32:06 +0800</pubDate>
      
      <guid>https://alvin-su.github.io/post/%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0/</guid>
      <description>调用函数本章学习创建自定义函数，包括声明参数和返回单个值、多个值。我们还将学习指针，以便进行高效的内存函数调用。
一些重复的代码我们需要计算两面墙的面积，看下面的代码：
func main(){  var width,height,area float64  //第一面墙的面积计算  width = 4.2  height = 3.0  area = width*height  fmt.Println(area/10,&amp;#34;liters needes&amp;#34;)  //第二面墙的面积计算  width=5.2  heigth=3.5  area=width*height  fmt.Println(area/10,&amp;#34;liters needes&amp;#34;) } 上面的代码存在两个问题：
 计算结果有异常精确的浮点值，我们只需要精确到两位小数。 有相当多的重复代码，如果需要计算十面墙的面积，那么代码量很可观。  下面我们就解决上面代码中存在的这两个问题，先看浮点数值得问题。
使用 Printf 和 Sprintf 格式化代码Go的 fmt 包提供了 Printf函数。Printf代表 带格式的打印 。它接受一个字符串并将一个或多个值插入其中，以特定的方式进行格式化。然后打印结果字符串: fmt.Printf(&amp;quot;About one-third:%0.2f\n&amp;quot;,1.0/3.0)。
Sprintf函数也是fmt包的一部分，它的工作方式和Printf函数类似，只是它是返回格式化后的字符串而不是打印它。 resultString := fmt.</description>
    </item>
    
    <item>
      <title>实体和值对象</title>
      <link>https://alvin-su.github.io/post/%E5%AE%9E%E4%BD%93%E5%92%8C%E5%80%BC%E5%AF%B9%E8%B1%A1%E4%BB%A5%E5%8F%8A%E8%81%9A%E5%90%88/</link>
      <pubDate>Wed, 01 Jun 2022 22:16:25 +0800</pubDate>
      
      <guid>https://alvin-su.github.io/post/%E5%AE%9E%E4%BD%93%E5%92%8C%E5%80%BC%E5%AF%B9%E8%B1%A1%E4%BB%A5%E5%8F%8A%E8%81%9A%E5%90%88/</guid>
      <description>实体、值对象以及聚合实体和值对象都是DDD战术设计中的两个重要概念。这两个概念都是领域模型中的领域对象。
实体拥有唯一标识符，且标识符在历经各种状态变更后仍能保持一致。对这些对象而言，重要的不是其属性，而是其延续性和标识，对象的延续性和标识会跨越甚至超出软件的生命周期。我们把这样的对象称为实体。
一个实体是一个唯一的东西，并且可以在相当长的一段时间内持续地变化。我们可以对实体做多次修改，故一个实体对象可能和它先前的状态大不相同。但是，由于它们拥有相同的身份标识(identity)，它们依然是同一个实体。
为什么需要实体CRUD&amp;ndash;面向数据库表建模开发的系统有时候并不能满足我们的业务需求，特别是随着业务的复杂性和多变带来的软件复杂性的增加，我们就越能体会现有 CRUD方式的不足。CRUD系统是不能创建出好的业务模型的。
在使用DDD的情况下，我们可以把原来的数据模型转变为实体模型。我们通过 标识 对对象进行区分，而不是属性，此时我们应该将标识作为主要的模型定义。同时我们需要保持简单的类定义，并且关注对象在其生命周期中的连续性和唯一标识性。我们不应该通过对象的状态形式和历史来区分不同的实体对象……对于什么是相同的东西，模型应该给出定义。
身份标识身份标识 (identity)是实体对象的必要标志，在DDD中，没用ID的领域对象就不是实体。实体的状态值可以变更，我们不能依据实体的属性值去判断其身份，如果没有唯一的ID我们就无法跟踪实体的状态变更。
属性实体的属性用来说明它的 静态特征 ，并持有数据与状态。我们又可以将属性进一步分为:原子属性 和 组合属性 。我们来看一断代码：
public class Product extends Entity&amp;lt;ProductId&amp;gt; {  private String name;  private int quantity;  private Category category; } 在上面的代码中 name和qunatity 是原子属性，分别被定义为 String和int类型，原子属性通常用开发语言（java或者C#）的内建类型。表达了不可再分性。Category为组合属性，通常用自定义类来表现，可以封装高内聚的一系列属性。
领域行为实体佣有领域行为，可以更好的说明它的动态特征。领域行为分为以下几种：
  变更状态的领域行为
实体对象允许调用者更改其状态，不仅仅是通过 get和 set访问器，应该让方法名满足业务含义，比如修改产品价格的领域行为应该定义为 ：changePriceTo(newPrice)的方法名，而非setPrice(newPrice)。</description>
    </item>
    
    <item>
      <title>Go-条件和循环</title>
      <link>https://alvin-su.github.io/post/go_%E6%9D%A1%E4%BB%B6%E5%92%8C%E5%BE%AA%E7%8E%AF/</link>
      <pubDate>Sun, 29 May 2022 09:51:35 +0800</pubDate>
      
      <guid>https://alvin-su.github.io/post/go_%E6%9D%A1%E4%BB%B6%E5%92%8C%E5%BE%AA%E7%8E%AF/</guid>
      <description>调用方法在 Go中，可以定义方法，方法其实是与特定 类型的值 关联的函数。看下面的代码，我们将调用 time 包中的方法。
package main  import (  &amp;#34;fmt&amp;#34;  &amp;#34;time&amp;#34; )  func main(){  var now time.Time = time.Now() //time.Now方法返回代表当前日期和时间的 time.Time值  var year int = now.Year() //返回年份的 Year方法  fmt.Println(year) } 上面看到调用方法的语法看起来很像调用不同包中的函数的语法，两者的区别是，函数属于一个包，而方法属于一个单独的值。这个值出现在圆点的左边。
下面使用 strings包中的Replacer类型中的Replace方法，替换字符串中的指定的要替换的字符串。
package main  import (  &amp;#34;fmt&amp;#34;  &amp;#34;strings&amp;#34;  &amp;#34;strings&amp;#34; )  func main(){  broken:=&amp;#34;G# r#cks&amp;#34;  replacer:=strings.NewReplacer(&amp;#34;#&amp;#34;,&amp;#34;o&amp;#34;)  fixed:=replacer.Replace(broken)  fmt.Println(fixed) } 获取用户输入的分数在控制台中获取用户输入的分数并打印出来。</description>
    </item>
    
    <item>
      <title>开始学习Go--语法基础</title>
      <link>https://alvin-su.github.io/post/go_begin/</link>
      <pubDate>Fri, 27 May 2022 21:18:02 +0800</pubDate>
      
      <guid>https://alvin-su.github.io/post/go_begin/</guid>
      <description>语法基础Go 是一种注重简单性和速度的编程语言。Go 语言的目标：
 快速编译 不太笨重的代码（语法简单） 自动释放未使用的内存（垃圾回收） 易于编写同时执行多个操作的软件（并发\协程） 很好的支持多核处理器  Go 程序代码结构package main  import &amp;#34;fmt&amp;#34;  func main(){  fmt.Println(&amp;#34;Hello,Go!&amp;#34;) } 上面是典型的Go文件代码布局，主要分三部分：
 package main 子句，表示该代码文件中的所有其余代码都属于 main 包。 import &amp;quot;fmt&amp;quot; 子句，表示我们导入了 fmt 包，可以使用里面公开的文本格式代码。 实际代码 每个Go文件的最后一部分都是实际代码，它通常被分割成一个或多个 function(函数)。main 包和main函数是 Go 程序的入口点。  调用函数调用函数的格式是：包名.函数名，比如 fmt.Println(),一个包中的函数可被其它包调用，前提是该函数是大写字母开头，表示是可导出的。
在代码中要使用其它包中的函数，首先要导入其它包，通过impport 子句。
import (  &amp;#34;fmt&amp;#34;  &amp;#34;math&amp;#34; ) 上面这种格式表示导入了两个包。
字符串字符串是一系列字节，通常表示文本字符，通过字面量定义字符：双引号之间的文本，Go将把他们视为字符串,&amp;quot;Hello,Go&amp;quot;。</description>
    </item>
    
    <item>
      <title>Dapr_k8s部署</title>
      <link>https://alvin-su.github.io/post/dapr_k8s/</link>
      <pubDate>Fri, 27 May 2022 09:49:01 +0800</pubDate>
      
      <guid>https://alvin-su.github.io/post/dapr_k8s/</guid>
      <description>在 Kubernetes集群中部署 DaprKubernetes 上的Dapr概述Dapr 可以配置为在任何受支持的Kubernetes版本上运行。主要通过 dapr-sidecar-inject、dapr-operator、dapr-placement和dapr-sentry k8s服务为dapr在k8s中运行提供支持。
 dapr-operator 为Dapr管理组件更新和kubernetes服务端点 (状态存储、发布/订阅等) dapr-sidecar-injector 将Dapr 注入带注解的deployment pods中，并添加环境变量 DAPR_HTTP_PORT 和 DAPR_GRPC_PORT，以使用户定义的应用程序能够轻松地与Dapr通信，而无需硬编码Dapr端口。 dapr-placement 仅用于actor，创建映射表，将actor实例映射到pod。 dapr-sentry 管理服务之间的mTLS 并充当证书的颁发机构。  在kubernetes 集群上部署 Dapr在K8s中安装Dapr有两种方式，一种是使用Dapr CLI,另外一种是使用Helm 在 kubernetes中部署Dapr。我这里主要介绍使用Helm的方式部署Dapr。
在centos7中安装K3sk3s概述k3s是一个高可用的、经过CNCF认证的Kubernetes发行版，专为物联网及边缘计算设计。k3s被打包成单个小于60MB的二进制文件，从而减少了运行安装、运行和自动更新生产Kubernetes集群所需的依赖性和步骤。k3s在小到树莓派或大到 AWS a1.4xlarge 32GiB服务器的环境中均能出色工作。
安装k3s安装命令: curl -sfL https://get.k3s.io | sh -s - server &amp;ndash;docker 最好指定 容器运行时为docker，否则默认的容器运行时为containerd</description>
    </item>
    
    <item>
      <title>领域、子域和限界上下文</title>
      <link>https://alvin-su.github.io/post/domain/</link>
      <pubDate>Fri, 27 May 2022 09:46:32 +0800</pubDate>
      
      <guid>https://alvin-su.github.io/post/domain/</guid>
      <description>DDD 领域、限界上下文领域学习领域驱动设计首先要理解里面的一些核心概念，DDD既然是以 领域 为核心概念，那么理解DDD里面的各种以 域 为概念的名词就非常的关键，是学习DDD的第一步和前提。
领域和子域  领域是从事一种专门活动或事业的 范围 、部类或部门，是指一种特定的 范围 或区域。领域其实就是来确定范围的，范围即边界。
  范围有大小之分，所以领域也有大小之分，根据领域确定的边界的大小可以将领域进一步划分出子域，每个子域对应一个更小的问题域或更小的业务范围。
  领域中存在着 问题空间 和 解决方案空间 在问题空间中我们思考的是业务面临的挑战，在解决方案空间中，我们思考如何实现软件以解决这些业务面临的挑战。
  一般我们研究一个比较大的问题，通常的做法就是将该问题拆分出几个小问题，对每一个小问题研究透了，那么我们就建立了整个大的问题域的知识体系，也就是建立了整个全域的领域模型。所以领域建模的核心思想是将问题域逐步分解，降低业务理解和系统实现的复杂度。
  核心域、通用域和支撑域在领域不断的划分的过程中（对问题空间的逐步分解），领域会细分为不同的子域，子域可以根据对业务的重要性和功能属性划分为三类子域：核心域、通用域和支撑域。
 核心域 在这三类子域中，核心域 是最重要的，我们应该投入最多的资源在核心域上。 支撑域 是指在关注于业务的某一个方面，但确不是核心，他们专注于业务的某个方面。比如数据字典等。 通用域 是指一个子域被用于整个业务系统，比如认证、权限等。  在系统建设过程中，由于预算和资源的有限，对于不同类型的子域应有不同的关注度和资源投入策略。
在微服务系统建设的过程中，技术团队要将核心域的建设排在首位，需要有绝对的掌控能力和自主研发能力。
限界上下文在DDD 领域建模和系统建设过程中，有很多的参与者，对于同样的领域知识，不同的参与者可能会有不同的理解，因此DDD就出现了 通用语言 和 限界上下文 这两个重要的概念。
限界上下文是一个显示的边界，领域模型便存在于这个边界之内。领域模型把通用语言表达成软件模型。创建边界的含义在于，每一个模型的概念，包括它的属性和操作，在边界之内都有特殊的含义，每一个参与者都应该知道确切的含义。
通用语言通用语言 是团队统一的语言，不管你在团队中承担什么角色，在同一个领域的软件生命周期里都使用统一的语言进行交流。</description>
    </item>
    
    <item>
      <title>什么是领域驱动设计</title>
      <link>https://alvin-su.github.io/post/%E4%BB%80%E4%B9%88%E6%98%AF%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Fri, 27 May 2022 09:26:30 +0800</pubDate>
      
      <guid>https://alvin-su.github.io/post/%E4%BB%80%E4%B9%88%E6%98%AF%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/</guid>
      <description>什么是领域驱动设计2004 年埃里克·埃文斯（Eric Evans）发表了《领域驱动设计》（Domain-Driven Design –Tackling Complexity in the Heart of Software）这本书，从此领域驱动设计（Domain Driven Design，简称 DDD）诞生。DDD 核心思想是通过领域驱动设计方法定义领域模型，从而确定业务和应用边界，保证业务模型与代码模型的一致性。 领域驱动设计是一种通过将实现连接到持续进化的模型来满足复杂需求的软件开发方法。
DDD设计的前提是：
 把项目的主要重点放在核心领域 把复杂的设计放在有界域（bounded context）的模型上 发起一个创造性的合作之间的技术和域界专家以迭代地完善的概念模式，解决特定领域的问题。  领域驱动设计是一种由域模型来驱动着系统设计的思想，不是通过存储数据词典(DB表字段、ES Mapper字段等等)来驱动系统设计。领域模型是对业务模型的抽象，DDD是把业务模型翻译成系统架构设计的一种方式。
微服务与DDD的关系DDD 提出后在软件开发领域一直都是“雷声大，雨点小”，直到 Martin Fowler 提出微服务架构，DDD 才真正迎来了自己的时代。
有些熟悉 DDD 设计方法的软件工程师在进行微服务设计时，发现可以利用 DDD 设计方法来建立领域模型，划分领域边界，再根据这些领域边界从业务视角来划分微服务边界。而按照 DDD 方法设计出的微服务的业务和应用边界都非常合理，可以很好地实现微服务内部和外部的“高内聚、低耦合”。于是越来越多的人开始把 DDD 作为微服务设计的指导思想。
DDD 是一种处理高度复杂领域的设计思想，它试图分离技术实现的复杂性，并围绕业务概念构建领域模型来控制业务的复杂性，以解决软件难以理解，难以演进的问题。DDD 不是架构，而是一种架构设计方法论，它通过边界划分将复杂业务领域简单化，帮我们设计出清晰的领域和应用边界，可以很容易地实现架构演进。
DDD 是一种架构设计方法，微服务是一种架构风格，两者从本质上都是为了追求高响应力，而从业务视角去分离应用系统建设复杂度的手段。两者都强调从业务出发，其核心要义是强调根据业务发展，合理划分领域边界，持续调整现有架构，优化现有代码，以保持架构和代码的生命力，也就是我们常说的演进式架构。
DDD 主要关注：从业务领域视角划分领域边界，构建通用语言进行高效沟通，通过业务抽象，建立领域模型，维持业务和代码的逻辑一致性。
微服务主要关注：运行时的进程间通信、容错和故障隔离，实现去中心化数据管理和去中心化服务治理，关注微服务的独立开发、测试、构建和部署。 .</description>
    </item>
    
    <item>
      <title>利用Hugo搭建个人博客站点</title>
      <link>https://alvin-su.github.io/post/hugo-site/</link>
      <pubDate>Thu, 26 May 2022 21:30:55 +0800</pubDate>
      
      <guid>https://alvin-su.github.io/post/hugo-site/</guid>
      <description>什么是HugoHugo 是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署,可以快速方便的创建自己的博客。
安装HugoHugo 因为是Go语言实现的 所以支持 Windows\Linux\MacOS 系统。因为日常办公只要是使用的Windows,所以这里只介绍Windows环境的安装。
在github上下载Hugo的最新版本，地址：https://github.com/gohugoio/hugo/releases 如下图：
下载下来后进行解压，进入目录只有一个hugo.exe 可执行文件，在系统环境变量path中，配置该exe的路径: 配置好环境变量后，就可以在powershell 中使用 hugo 命令，利用 hugo version 命令查看下hugo 的版本
创建博客站点可以方便的利用 hugo new site myblog 命令创建一个名为 “myblog” 的博客。
我们进入到myblog里面，可以看到如下内容:
添加博客主题可以在 https://themes.gohugo.io/选择自己喜欢的主题进行下载，比如选择 m10c 主题，可以通过下面的命令进行下载： git clone https://github.com/vaga/hugo-theme-m10c.git themes/m10c
输入命令 hugo server -t m10c &amp;ndash;buildDrafts 启动站点
创建博客文章通过命令 hugo new post/myfirst.md 创建一个 myfirst.md 的文件。</description>
    </item>
    
  </channel>
</rss>
