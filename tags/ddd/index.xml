<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DDD on Alvinsu Blog</title>
    <link>https://alvin-su.github.io/tags/ddd/</link>
    <description>Recent content in DDD on Alvinsu Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 09 Jun 2022 10:16:35 +0800</lastBuildDate><atom:link href="https://alvin-su.github.io/tags/ddd/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>领域事件和DDD分层架构</title>
      <link>https://alvin-su.github.io/post/%E9%A2%86%E5%9F%9F%E4%BA%8B%E4%BB%B6%E5%92%8Cddd%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Thu, 09 Jun 2022 10:16:35 +0800</pubDate>
      
      <guid>https://alvin-su.github.io/post/%E9%A2%86%E5%9F%9F%E4%BA%8B%E4%BB%B6%E5%92%8Cddd%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84/</guid>
      <description>领域事件和DDD分层架构在理解领域事件之前，我们先来看看什么是领域服务
领域服务我们先来看聚合存在的三个问题：
  聚合无法封装不稳定的领域行为
聚合封装了多个实体和值对象，聚合根是访问聚合的唯一入口点。领域行为被固化在聚合之中，问题在于，虽然一些领域行为需要访问集合封装的信息，它的实现却不稳定，常常随着需求的变化而变化。无法将领域行为分配到一个固定的对象。
  两个聚合之间的协作该由谁发起负责？
多数时候，一个自治的聚合无法完成一个完整的业务服务，聚合之间需要协作。比如一个聚合的根实体作为参数传递给另一个聚合根实体的方法，去完成行为的协作。那么这两个位聚合之间的协作该由谁负责？
  聚合如何与外部组件协作？
聚合是领域层的自治设计单元，封装了系统最为核心的业务功能。为了保证领域模型的纯粹性，会分离领域逻辑与技术实现，但是为了满足完整业务需要，二者又需要有机的结合起来。
  为了解决上面三个问题，需要引入领域服务的概念。领域服务 与实体、值对象一样，表示了领域模型。它封装了领域行为，前提是改领域行为在实体和值对象中找不到栖息之地。领域服务是领域设计建模的最后选择。
为了限制领域服务的范围，防止削弱聚合内实体和值对象的领域行为，我们需要控制领域服务的粒度，保证领域服务实现一个单一职责的领域行为，领域服务并不反映真实世界的领域概念（名词），而是单纯的体现一种领域行为（动词）。所以在领域服务的命名上必须包含动词，比如：OrderDeletionService这样的类，体现了领域服务的行为本质。
领域服务的运用场景领域服务是为了解决聚合的三个问题的
  聚合无法封装不稳定的领域行为
比如一个调查问卷的聚合，业务需求现在要求将调查问卷导出为CSV格式，隔一段时间又要求导出为JSON格式。转换行为操作由调查问卷聚合拥有，但是转换行为存在着多种变化，不同的格式代表了不同的实现。显然，该行为的变化原因与调查问卷的结构无关，所以我们需要将转换行为和聚合分开，分离变化与不变，变化的领域行为从聚合中分离出来，形成领域服务。
  两个聚合之间的协作该由谁负责?
多数时候，一个自治的聚合无法完成一个完整的业务需求，聚合之间需要协作。通常是一个聚合的根实体作为参数传递给另一个聚合根实体的方法，从而完成行为的协作。
聚合的生命周期由资源库管理，故而两个聚合的协作行为之上，需要引入一个设计对象负责聚合的协作。这个设计对象就是 领域服务 。
领域服务调用资源库获得聚合，发起它们之间的行为协作。
 聚合如何与外部组件的协作?  在业务系统中，几乎不可能让领域逻辑完全不依赖于任何外部资源，如果领域行为突破了聚合的粒度，就需要与外部资源进行协作，比如访问南北向的网关，这个协作就交由领域服务来实现，
  哪些领域行为要分配给聚合，哪些因为聚合无法做到，才会考虑分配给领域服务？
 与状态无关的领域行为 变化方向与聚合不一致的领域行为 聚合之间协作的领域行为 聚合和端口之间协作的领域行为  领域事件领域事件重点关注 状态 这两个字，在进行领域建模时，状态往往作为对象的属性被定义，例如，订单对象定义的订单状态的属性Created、Registered、Canceled等等。领域驱动设计将状态赋予它 领域事件 的身份。领域事件具有如下特征：
 领域事件代表了领域概念 领域事件是已经发送的事实 领域事件是不可变的领域对象 领域事件会基于某个条件而触发  领域事件的命名应采用动词的过去时态，如订单完成的事件命名为OrderCompleted。作为不变事实的领域事件可以参考值对象的定义要求，定义为不变类。</description>
    </item>
    
    <item>
      <title>实体和值对象</title>
      <link>https://alvin-su.github.io/post/%E5%AE%9E%E4%BD%93%E5%92%8C%E5%80%BC%E5%AF%B9%E8%B1%A1%E4%BB%A5%E5%8F%8A%E8%81%9A%E5%90%88/</link>
      <pubDate>Wed, 01 Jun 2022 22:16:25 +0800</pubDate>
      
      <guid>https://alvin-su.github.io/post/%E5%AE%9E%E4%BD%93%E5%92%8C%E5%80%BC%E5%AF%B9%E8%B1%A1%E4%BB%A5%E5%8F%8A%E8%81%9A%E5%90%88/</guid>
      <description>实体、值对象以及聚合实体和值对象都是DDD战术设计中的两个重要概念。这两个概念都是领域模型中的领域对象。
实体拥有唯一标识符，且标识符在历经各种状态变更后仍能保持一致。对这些对象而言，重要的不是其属性，而是其延续性和标识，对象的延续性和标识会跨越甚至超出软件的生命周期。我们把这样的对象称为实体。
一个实体是一个唯一的东西，并且可以在相当长的一段时间内持续地变化。我们可以对实体做多次修改，故一个实体对象可能和它先前的状态大不相同。但是，由于它们拥有相同的身份标识(identity)，它们依然是同一个实体。
为什么需要实体CRUD&amp;ndash;面向数据库表建模开发的系统有时候并不能满足我们的业务需求，特别是随着业务的复杂性和多变带来的软件复杂性的增加，我们就越能体会现有 CRUD方式的不足。CRUD系统是不能创建出好的业务模型的。
在使用DDD的情况下，我们可以把原来的数据模型转变为实体模型。我们通过 标识 对对象进行区分，而不是属性，此时我们应该将标识作为主要的模型定义。同时我们需要保持简单的类定义，并且关注对象在其生命周期中的连续性和唯一标识性。我们不应该通过对象的状态形式和历史来区分不同的实体对象……对于什么是相同的东西，模型应该给出定义。
身份标识身份标识 (identity)是实体对象的必要标志，在DDD中，没用ID的领域对象就不是实体。实体的状态值可以变更，我们不能依据实体的属性值去判断其身份，如果没有唯一的ID我们就无法跟踪实体的状态变更。
属性实体的属性用来说明它的 静态特征 ，并持有数据与状态。我们又可以将属性进一步分为:原子属性 和 组合属性 。我们来看一断代码：
public class Product extends Entity&amp;lt;ProductId&amp;gt; {  private String name;  private int quantity;  private Category category; } 在上面的代码中 name和qunatity 是原子属性，分别被定义为 String和int类型，原子属性通常用开发语言（java或者C#）的内建类型。表达了不可再分性。Category为组合属性，通常用自定义类来表现，可以封装高内聚的一系列属性。
领域行为实体佣有领域行为，可以更好的说明它的动态特征。领域行为分为以下几种：
  变更状态的领域行为
实体对象允许调用者更改其状态，不仅仅是通过 get和 set访问器，应该让方法名满足业务含义，比如修改产品价格的领域行为应该定义为 ：changePriceTo(newPrice)的方法名，而非setPrice(newPrice)。</description>
    </item>
    
    <item>
      <title>领域、子域和限界上下文</title>
      <link>https://alvin-su.github.io/post/domain/</link>
      <pubDate>Fri, 27 May 2022 09:46:32 +0800</pubDate>
      
      <guid>https://alvin-su.github.io/post/domain/</guid>
      <description>DDD 领域、限界上下文领域学习领域驱动设计首先要理解里面的一些核心概念，DDD既然是以 领域 为核心概念，那么理解DDD里面的各种以 域 为概念的名词就非常的关键，是学习DDD的第一步和前提。
领域和子域  领域是从事一种专门活动或事业的 范围 、部类或部门，是指一种特定的 范围 或区域。领域其实就是来确定范围的，范围即边界。
  范围有大小之分，所以领域也有大小之分，根据领域确定的边界的大小可以将领域进一步划分出子域，每个子域对应一个更小的问题域或更小的业务范围。
  领域中存在着 问题空间 和 解决方案空间 在问题空间中我们思考的是业务面临的挑战，在解决方案空间中，我们思考如何实现软件以解决这些业务面临的挑战。
  一般我们研究一个比较大的问题，通常的做法就是将该问题拆分出几个小问题，对每一个小问题研究透了，那么我们就建立了整个大的问题域的知识体系，也就是建立了整个全域的领域模型。所以领域建模的核心思想是将问题域逐步分解，降低业务理解和系统实现的复杂度。
  核心域、通用域和支撑域在领域不断的划分的过程中（对问题空间的逐步分解），领域会细分为不同的子域，子域可以根据对业务的重要性和功能属性划分为三类子域：核心域、通用域和支撑域。
 核心域 在这三类子域中，核心域 是最重要的，我们应该投入最多的资源在核心域上。 支撑域 是指在关注于业务的某一个方面，但确不是核心，他们专注于业务的某个方面。比如数据字典等。 通用域 是指一个子域被用于整个业务系统，比如认证、权限等。  在系统建设过程中，由于预算和资源的有限，对于不同类型的子域应有不同的关注度和资源投入策略。
在微服务系统建设的过程中，技术团队要将核心域的建设排在首位，需要有绝对的掌控能力和自主研发能力。
限界上下文在DDD 领域建模和系统建设过程中，有很多的参与者，对于同样的领域知识，不同的参与者可能会有不同的理解，因此DDD就出现了 通用语言 和 限界上下文 这两个重要的概念。
限界上下文是一个显示的边界，领域模型便存在于这个边界之内。领域模型把通用语言表达成软件模型。创建边界的含义在于，每一个模型的概念，包括它的属性和操作，在边界之内都有特殊的含义，每一个参与者都应该知道确切的含义。
通用语言通用语言 是团队统一的语言，不管你在团队中承担什么角色，在同一个领域的软件生命周期里都使用统一的语言进行交流。</description>
    </item>
    
    <item>
      <title>什么是领域驱动设计</title>
      <link>https://alvin-su.github.io/post/%E4%BB%80%E4%B9%88%E6%98%AF%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Fri, 27 May 2022 09:26:30 +0800</pubDate>
      
      <guid>https://alvin-su.github.io/post/%E4%BB%80%E4%B9%88%E6%98%AF%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/</guid>
      <description>什么是领域驱动设计2004 年埃里克·埃文斯（Eric Evans）发表了《领域驱动设计》（Domain-Driven Design –Tackling Complexity in the Heart of Software）这本书，从此领域驱动设计（Domain Driven Design，简称 DDD）诞生。DDD 核心思想是通过领域驱动设计方法定义领域模型，从而确定业务和应用边界，保证业务模型与代码模型的一致性。 领域驱动设计是一种通过将实现连接到持续进化的模型来满足复杂需求的软件开发方法。
DDD设计的前提是：
 把项目的主要重点放在核心领域 把复杂的设计放在有界域（bounded context）的模型上 发起一个创造性的合作之间的技术和域界专家以迭代地完善的概念模式，解决特定领域的问题。  领域驱动设计是一种由域模型来驱动着系统设计的思想，不是通过存储数据词典(DB表字段、ES Mapper字段等等)来驱动系统设计。领域模型是对业务模型的抽象，DDD是把业务模型翻译成系统架构设计的一种方式。
微服务与DDD的关系DDD 提出后在软件开发领域一直都是“雷声大，雨点小”，直到 Martin Fowler 提出微服务架构，DDD 才真正迎来了自己的时代。
有些熟悉 DDD 设计方法的软件工程师在进行微服务设计时，发现可以利用 DDD 设计方法来建立领域模型，划分领域边界，再根据这些领域边界从业务视角来划分微服务边界。而按照 DDD 方法设计出的微服务的业务和应用边界都非常合理，可以很好地实现微服务内部和外部的“高内聚、低耦合”。于是越来越多的人开始把 DDD 作为微服务设计的指导思想。
DDD 是一种处理高度复杂领域的设计思想，它试图分离技术实现的复杂性，并围绕业务概念构建领域模型来控制业务的复杂性，以解决软件难以理解，难以演进的问题。DDD 不是架构，而是一种架构设计方法论，它通过边界划分将复杂业务领域简单化，帮我们设计出清晰的领域和应用边界，可以很容易地实现架构演进。
DDD 是一种架构设计方法，微服务是一种架构风格，两者从本质上都是为了追求高响应力，而从业务视角去分离应用系统建设复杂度的手段。两者都强调从业务出发，其核心要义是强调根据业务发展，合理划分领域边界，持续调整现有架构，优化现有代码，以保持架构和代码的生命力，也就是我们常说的演进式架构。
DDD 主要关注：从业务领域视角划分领域边界，构建通用语言进行高效沟通，通过业务抽象，建立领域模型，维持业务和代码的逻辑一致性。
微服务主要关注：运行时的进程间通信、容错和故障隔离，实现去中心化数据管理和去中心化服务治理，关注微服务的独立开发、测试、构建和部署。 .</description>
    </item>
    
  </channel>
</rss>
